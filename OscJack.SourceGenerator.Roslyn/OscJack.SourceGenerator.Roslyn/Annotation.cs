using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OscJack.SourceGenerator.Roslyn;
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Text;

namespace OscJack.Annotation.Generator
{
    [Generator(LanguageNames.CSharp)]
    internal class OscPacketSourceGenerator : IIncrementalGenerator
    {
        public const string PacketAttribute = "OscJack.Annotation.OscPackableAttribute";
        public const string PacketElementAttribute = "OscJack.Annotation.OscElementOrderAttribute";
        public const string TypeInt = "int";
        public const string TypeFloat = "float";
        public const string TypeString = "string";
        public const string TypeByteArray = "byte[]";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                PacketAttribute,
                (node, cancellationToken) =>
                {
                    // クラスか構造体
                    return node is ClassDeclarationSyntax || node is StructDeclarationSyntax;
                },
                (context, cancellationToken) => context
                );

            context.RegisterSourceOutput(source, EmitConstructor);
        }

        private static void EmitConstructor(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
        {
            // Hookされたクラスに対して処理する
            var typeSymbol = source.TargetSymbol as INamedTypeSymbol;
            var typeDecralation = source.TargetNode as TypeDeclarationSyntax;
            // 単一であるため、最初の要素を取ればよく、Indexのみであるため
            var attribute = source.Attributes[0];

            string fullTypeName = typeSymbol.ToDisplayString();

            // partial classでない場合はスキップ
            if (!typeDecralation!.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                return;
            }

            // memberを取得
            var members = typeSymbol.GetMembers();
            var injects = new List<(ITypeSymbol, ISymbol, int)>();

            foreach (var member in members)
            {
                // Attributeが付与されているか
                var attributes = member.GetAttributes();
                if (attributes.Count() < 1)
                {
                    continue;
                }

                // OscPacketElementAttributeが付与されているか
                var oscPacketElementAttribute =
                    attributes.FirstOrDefault(a => a.AttributeClass.ToDisplayString() == PacketElementAttribute);
                // 付与されていない場合はスキップ
                if (oscPacketElementAttribute == null)
                {
                    continue;
                }

                // Indexを取得
                if (oscPacketElementAttribute.ConstructorArguments[0].Value is not int index)
                {
                    continue;
                }

                if(member is IPropertySymbol property)
                {
                    injects.Add((property.Type, member, index));
                }
                else if (member is IFieldSymbol field)
                {
                    injects.Add((field.Type, member, index));
                }
            }

            injects.Sort((a, b) => a.Item3 - b.Item3);

            // indexが連番でない場合はコンパイルエラーとする
            for (int i = 0; i < injects.Count; i++)
            {
                if (injects[i].Item3 != i)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "OSCJACK001",
                            "Index is not sequential.",
                            "Index is not sequential.",
                            "OscJack.Annotation.Generator",
                            DiagnosticSeverity.Error,
                            true
                        ),
                        Location.None
                    ));
                    context.AddSource($"{fullTypeName}.g.cs", "// <auto-generated/> Index is not sequential.");
                    return;
                }
            }

            var cb = new CodeBuilder();
            cb.AppendLine("// <auto-generated>");
            cb.AppendLine("using System;");
            cb.AppendLine("using OscJack;");
            cb.AppendLine("");

            using (var gClass = cb.BeginScope($"partial class {fullTypeName}"))
            {
                // コンストラクタを追加
                using (var gConstructor = cb.BeginScope($"public {fullTypeName}(OscDataHandle handle)"))
                {
                    foreach (var (type, member, index) in injects)
                    {
                        // プロパティかフィールドのみ
                        if(member.Kind != SymbolKind.Property && member.Kind != SymbolKind.Field)
                        {
                            continue;
                        }

                        string memberName = member.Name;
                        string displayType = type.ToDisplayString();

                        switch(displayType)
                        {
                            case TypeInt:
                                cb.AppendLine($"this.{memberName} = handle.GetElementAsInt({index});");
                                break;
                            case TypeFloat:
                                cb.AppendLine($"this.{memberName} = handle.GetElementAsFloat({index});");
                                break;
                            case TypeString:
                                cb.AppendLine($"this.{memberName} = handle.GetElementAsString({index});");
                                break;
                            case TypeByteArray:
                                cb.AppendLine($"this.{memberName} = handle.GetElementAsBlob({index});");
                                break;
                            default:
                                cb.AppendLine($"// ({memberName}) {displayType} is not supported.");
                                break;
                        }
                    }
                }

                using (var gToObjects = cb.BeginScope("public object[] ToObjects()"))
                {
                    if (injects.Count < 1)
                    {
                        cb.AppendLine("return new object[0];");
                    }
                    else
                    {
                        cb.AppendLine($"object[] objects = new object[{injects.Max(i => i.Item3) + 1}];");
                        foreach(var (type, member, index) in injects)
                        {
                            string memberName = member.Name;
                            string displayType = type.ToDisplayString();
                            switch (displayType)
                            {
                                case TypeInt:
                                    cb.AppendLine($"objects[{index}] = this.{memberName};");
                                    break;
                                case TypeFloat:
                                    cb.AppendLine($"objects[{index}] = this.{memberName};");
                                    break;
                                case TypeString:
                                    cb.AppendLine($"objects[{index}] = this.{memberName};");
                                    break;
                                case TypeByteArray:
                                    cb.AppendLine($"objects[{index}] = this.{memberName};");
                                    break;
                                default:
                                    cb.AppendLine($"// ({memberName}) {displayType} is not supported.");
                                    break;
                            }
                        }
                        cb.AppendLine("return objects;");
                    }
                }
            }
            cb.AppendLine("// </auto-generated>");

            context.AddSource($"{fullTypeName}.g.cs", cb.ToString());
        }
    }
}